>> initCobraToolbox

% 设置求解器
changeCobraSolver('gurobi','all')
fullPath = which('tutorial_optKnock_extended');
folder = fileparts(fullPath);
currectDirectory = pwd;
cd(folder);


      _____   _____   _____   _____     _____     |
     /  ___| /  _  \ |  _  \ |  _  \   / ___ \    |   COnstraint-Based Reconstruction and Analysis
     | |     | | | | | |_| | | |_| |  | |___| |   |   The COBRA Toolbox - 2025
     | |     | | | | |  _  { |  _  /  |  ___  |   |
     | |___  | |_| | | |_| | | | \ \  | |   | |   |   Documentation:
     \_____| \_____/ |_____/ |_|  \_\ |_|   |_|   |   http://opencobra.github.io/cobratoolbox
                                                  | 

 > Checking if git is installed ...  Done (version: 2.47.1).
 > Checking if the repository is tracked using git ...  Done.
 > Checking if curl is installed ...  Done.
 > Checking if remote can be reached ...  Done.
 > Initializing and updating submodules (this may take a while)... Done.
 > Adding all the files of The COBRA Toolbox ...  Done.
 > Define CB map output... set to svg.
 > TranslateSBML is installed and working properly.
 > Configuring solver environment variables ...
   - [*---] ILOG_CPLEX_PATH: --> set this path manually after installing the solver ( see instructions )
   - [*---] GUROBI_PATH: C:\gurobi1200\win64\matlab
   - [*---] TOMLAB_PATH: --> set this path manually after installing the solver ( see instructions )
   - [*---] MOSEK_PATH: --> set this path manually after installing the solver ( see instructions )
   Done.
 > Checking available solvers and solver interfaces ...Could not find installation of dqqMinos, so it cannot be tested
Could not find installation of mosek, so it cannot be tested
Could not find installation of quadMinos, so it cannot be tested
Could not find installation of tomlab_snopt, so it cannot be tested
 Done.
 > Setting default solvers ...Could not find installation of mosek, so it cannot be tested
Could not find installation of mosek, so it cannot be tested
 Done.
 > Saving the MATLAB path ... Done.
   - The MATLAB path was saved in the default location.

 > Summary of available solvers and solver interfaces

					Support           LP 	 MILP 	   QP 	 MIQP 	  NLP 	   EP 	  CLP
	------------------------------------------------------------------------------
	dqqMinos     	active        	    0 	    - 	    0 	    - 	    - 	    - 	    -
	glpk         	active        	    1 	    1 	    - 	    - 	    - 	    - 	    -
	gurobi       	active        	    1 	    1 	    1 	    1 	    - 	    - 	    -
	lp_solve     	legacy        	    1 	    - 	    - 	    - 	    - 	    - 	    -
	matlab       	active        	    1 	    - 	    - 	    - 	    1 	    - 	    -
	mosek        	active        	    0 	    - 	    0 	    - 	    - 	    0 	    0
	pdco         	active        	    1 	    - 	    1 	    - 	    - 	    1 	    -
	qpng         	passive       	    - 	    - 	    1 	    - 	    - 	    - 	    -
	quadMinos    	active        	    0 	    - 	    - 	    - 	    - 	    - 	    -
	tomlab_snopt 	passive       	    - 	    - 	    - 	    - 	    0 	    - 	    -
	------------------------------------------------------------------------------
	Total        	-             	    5 	    2 	    3 	    1 	    1 	    1 	    0

 + Legend: - = not applicable, 0 = solver not compatible or not installed, 1 = solver installed.


 > You can solve LP problems using: 'gurobi' - 'glpk' - 'matlab' - 'pdco' 
 > You can solve MILP problems using: 'gurobi' - 'glpk' 
 > You can solve QP problems using: 'gurobi' - 'pdco' 
 > You can solve MIQP problems using: 'gurobi' 
 > You can solve NLP problems using: 'matlab' 
 > You can solve EP problems using: 'pdco' 
 > You can solve CLP problems using: 

 > Checking for available updates ...
 > There are 9720 new commit(s) on <master> and 0 new commit(s) on <develop> [a6b11d @ master]
 > You can update The COBRA Toolbox by running updateCobraToolbox() (from within MATLAB).
removing: D:\Professional\MATLAB\toolbox\cobratoolbox\src\analysis\thermo\componentContribution\new
removing: D:\Professional\MATLAB\toolbox\cobratoolbox\src\analysis\thermo\groupContribution\new
removing: D:\Professional\MATLAB\toolbox\cobratoolbox\src\analysis\thermo\inchi\new
removing: D:\Professional\MATLAB\toolbox\cobratoolbox\src\analysis\thermo\molFiles\new
removing: D:\Professional\MATLAB\toolbox\cobratoolbox\src\analysis\thermo\protons\new
removing: D:\Professional\MATLAB\toolbox\cobratoolbox\src\analysis\thermo\trainingModel\new

 > changeCobraSolver: Gurobi interface added to MATLAB path.
 > changeCobraSolver: Solver for LP problems has been set to gurobi.

 > changeCobraSolver: Gurobi interface added to MATLAB path.
 > changeCobraSolver: Solver for MILP problems has been set to gurobi.

 > changeCobraSolver: Gurobi interface added to MATLAB path.
 > changeCobraSolver: Solver for QP problems has been set to gurobi.

 > changeCobraSolver: Gurobi interface added to MATLAB path.
 > changeCobraSolver: Solver for MIQP problems has been set to gurobi.
 > changeCobraSolver: Solver gurobi not supported for problems of type CLP. No solver set for this problemtype 
 > changeCobraSolver: Solver gurobi not supported for problems of type EP. No solver set for this problemtype 
 > changeCobraSolver: Solver gurobi not supported for problems of type NLP. Currently used: matlab 

ans =

  logical

   1

>> modelFileName = 'iJO1366.mat'
modelDirectory = getDistributedModelFolder(modelFileName) % 查找分布式模型的文件夹
modelFileName= [modelDirectory filesep modelFileName] % 获取完整路径
model = readCbModel(modelFileName)

% 定义生物质反应
biomass = 'BIOMASS_Ec_iJO1366_core_53p95M';

modelFileName =

    'iJO1366.mat'


modelDirectory =

    'D:\Professional\MATLAB\toolbox\cobratoolbox\test\models\mat'


modelFileName =

    'D:\Professional\MATLAB\toolbox\cobratoolbox\test\models\mat\iJO1366.mat'

Each model.subSystems{x} is a character array, and this format is retained.

model = 

  包含以下字段的 struct:

              S: [1805×2583 double]
           mets: {1805×1 cell}
              b: [1805×1 double]
         csense: [1805×1 char]
           rxns: {2583×1 cell}
             lb: [2583×1 double]
             ub: [2583×1 double]
              c: [2583×1 double]
      osenseStr: 'max'
          genes: {1367×1 cell}
          rules: {2583×1 cell}
     metCharges: [1805×1 double]
    metFormulas: {1805×1 cell}
       metNames: {1805×1 cell}
        grRules: {2583×1 cell}
     rxnGeneMat: [2583×1367 double]
       rxnNames: {2583×1 cell}
     subSystems: {2583×1 cell}
    description: 'iJO1366.mat'
        modelID: 'iJO1366'

>> %% 定义基本参数
% 定义要找到的最大解数量（即可删除反应的最大数量）

threshold = 10; % 增加阈值以获得更多方案
>> %% 方案一：不同葡萄糖摄取量的比较
fprintf('\n=== 方案一：不同葡萄糖摄取量的比较 ===\n');

% 定义不同的葡萄糖摄取量
glucoseUptakeRates = [5, 10, 15, 20]; % mmol/grDW*hr
resultsGlucose = struct();

for i = 1:length(glucoseUptakeRates)
    glucoseUptake = glucoseUptakeRates(i);
    fprintf('\n--- 葡萄糖摄取量: %d mmol/grDW*hr ---\n', glucoseUptake);

    % 创建模型副本
    modelCurrent = model;

    % 设置葡萄糖摄取量
    modelCurrent = changeRxnBounds(modelCurrent, 'EX_glc__D_e', -glucoseUptake, 'b');

    % 设置基本约束
    % 无约束的无机磷酸盐、硫酸盐和氨摄取路径
    Exchange={'EX_o2_e';'EX_pi_e';'EX_so4_e'; 'EX_nh4_e'};
    Bounds=[0;-1000;-1000;-1000];
    modelCurrent = changeRxnBounds(modelCurrent, Exchange, Bounds, 'l');

    % 启用乙酸盐、二氧化碳、乙醇、甲酸盐、乳酸盐和琥珀酸盐的分泌路径
    Exchange={'EX_ac_e';'EX_co2_e';'EX_etoh_e';'EX_for_e';'EX_lac__D_e';'EX_succ_e'};
    Bounds=[1000;1000;1000;1000;1000;1000];
    modelCurrent = changeRxnBounds(modelCurrent, Exchange, Bounds, 'u');

    % 约束磷酸转移酶系统
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCabcpp', -1000, 'l');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCptspp', -1000, 'l');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCabcpp', 1000, 'u');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCptspp', 1000, 'u');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCt2pp', 0, 'b');

    % 计算优化前的琥珀酸产量
    fbaWT = optimizeCbModel(modelCurrent);
    succFluxWT = fbaWT.x(strcmp(modelCurrent.rxns, 'EX_succ_e'));
    growthRateWT = fbaWT.f;
    fprintf('优化前的琥珀酸产量: %.1f\n', succFluxWT);
    fprintf('优化前的生长速率: %.1f\n', growthRateWT);

    % 定义要搜索敲除的反应集合
    selectedRxnList = {'GLCabcpp'; 'GLCptspp'; 'HEX1'; 'PGI'; 'PFK'; 'FBA'; 'TPI'; 'GAPD'; ...
                       'PGK'; 'PGM'; 'ENO'; 'PYK'; 'LDH_D'; 'PFL'; 'ALCD2x'; 'PTAr'; 'ACKr'; ...
                       'G6PDH2r'; 'PGL'; 'GND'; 'RPI'; 'RPE'; 'TKT1'; 'TALA'; 'TKT2'; 'FUM'; ...
                       'FRD2'; 'SUCOAS'; 'AKGDH'; 'ACONTa'; 'ACONTb'; 'ICDHyr'; 'CS'; 'MDH'; ...
                       'MDH2'; 'MDH3'; 'ACALD'};

    % 设置optKnock选项
    options = struct('targetRxn', 'EX_succ_e', 'numDel', 2);
    constrOpt = struct('rxnList', {{biomass}}, 'values', 0.5*fbaWT.f, 'sense', 'G');

    % 运行optKnock
    optKnockSol = OptKnock(modelCurrent, selectedRxnList, options, constrOpt);

    % 存储结果
    resultsGlucose(i).glucoseUptake = glucoseUptake;
    resultsGlucose(i).wildTypeSuccinate = succFluxWT;
    resultsGlucose(i).wildTypeGrowth = growthRateWT;

    if ~isempty(optKnockSol.rxnList)
        succFluxOpt = optKnockSol.fluxes(strcmp(modelCurrent.rxns, 'EX_succ_e'));
        growthRateOpt = optKnockSol.fluxes(strcmp(modelCurrent.rxns, biomass));
        resultsGlucose(i).optimizedSuccinate = succFluxOpt;
        resultsGlucose(i).optimizedGrowth = growthRateOpt;
        resultsGlucose(i).knockoutReactions = optKnockSol.rxnList;
        resultsGlucose(i).improvement = (succFluxOpt - succFluxWT) / succFluxWT * 100;

        fprintf('找到的敲除组合: ');
        for j = 1:length(optKnockSol.rxnList)
            if j == 1
                fprintf('%s', optKnockSol.rxnList{j});
            elseif j == length(optKnockSol.rxnList)
                fprintf(' 和 %s', optKnockSol.rxnList{j});
            else
                fprintf(', %s', optKnockSol.rxnList{j});
            end
        end
        fprintf('\n');
        fprintf('优化后的琥珀酸产量: %.2f\n', succFluxOpt);
        fprintf('优化后的生长速率: %.2f\n', growthRateOpt);
        fprintf('产量提升: %.1f%%\n', resultsGlucose(i).improvement);
    else
        resultsGlucose(i).optimizedSuccinate = succFluxWT;
        resultsGlucose(i).optimizedGrowth = growthRateWT;
        resultsGlucose(i).knockoutReactions = {};
        resultsGlucose(i).improvement = 0;
        fprintf('未找到有效的敲除组合\n');
    end
end

=== 方案一：不同葡萄糖摄取量的比较 ===

--- 葡萄糖摄取量: 5 mmol/grDW*hr ---
优化前的琥珀酸产量: 0.0
优化前的生长速率: 0.1
找到的敲除组合: PFL 和 RPI
优化后的琥珀酸产量: 1.37
优化后的生长速率: 0.07
产量提升: 3907.5%

--- 葡萄糖摄取量: 10 mmol/grDW*hr ---
优化前的琥珀酸产量: 0.1
优化前的生长速率: 0.2
找到的敲除组合: PFL 和 RPI
优化后的琥珀酸产量: 2.75
优化后的生长速率: 0.14
产量提升: 3329.8%

--- 葡萄糖摄取量: 15 mmol/grDW*hr ---
优化前的琥珀酸产量: 0.1
优化前的生长速率: 0.4
找到的敲除组合: PFL 和 RPI
优化后的琥珀酸产量: 4.12
优化后的生长速率: 0.21
产量提升: 3172.5%

--- 葡萄糖摄取量: 20 mmol/grDW*hr ---
优化前的琥珀酸产量: 0.2
优化前的生长速率: 0.5
找到的敲除组合: PFL 和 RPI
优化后的琥珀酸产量: 5.49
优化后的生长速率: 0.28
产量提升: 3099.2%
>> %% 方案二：是否启用不同分泌路径的比较
fprintf('\n=== 方案二：是否启用不同分泌路径的比较 ===\n');

% 定义不同的分泌路径配置
secretionConfigs = {
    {'EX_ac_e'}, % 仅乙酸盐
    {'EX_co2_e'}, % 仅二氧化碳
    {'EX_etoh_e'}, % 仅乙醇
    {'EX_for_e'}, % 仅甲酸盐
    {'EX_lac__D_e'}, % 仅乳酸盐
    {'EX_succ_e'}, % 仅琥珀酸盐
    {'EX_ac_e';'EX_co2_e';'EX_etoh_e';'EX_for_e';'EX_lac__D_e';'EX_succ_e'}, % 全部启用
    {} % 全部禁用
};

configNames = {
    '仅乙酸盐',
    '仅二氧化碳',
    '仅乙醇',
    '仅甲酸盐',
    '仅乳酸盐',
    '仅琥珀酸盐',
    '全部启用',
    '全部禁用'
};

resultsSecretion = struct();

for i = 1:length(secretionConfigs)
    fprintf('\n--- 分泌配置: %s ---\n', configNames{i});

    % 创建模型副本
    modelCurrent = model;

    % 设置葡萄糖摄取量为10
    modelCurrent = changeRxnBounds(modelCurrent, 'EX_glc__D_e', -10, 'b');

    % 设置基本约束
    Exchange={'EX_o2_e';'EX_pi_e';'EX_so4_e'; 'EX_nh4_e'};
    Bounds=[0;-1000;-1000;-1000];
    modelCurrent = changeRxnBounds(modelCurrent, Exchange, Bounds, 'l');

    % 设置分泌路径约束
    allSecretions = {'EX_ac_e';'EX_co2_e';'EX_etoh_e';'EX_for_e';'EX_lac__D_e';'EX_succ_e'};
    for j = 1:length(allSecretions)
        if ismember(allSecretions{j}, secretionConfigs{i})
            % 启用分泌
            modelCurrent = changeRxnBounds(modelCurrent, allSecretions{j}, 1000, 'u');
        else
            % 禁用分泌
            modelCurrent = changeRxnBounds(modelCurrent, allSecretions{j}, 0, 'u');
        end
    end

    % 约束磷酸转移酶系统
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCabcpp', -1000, 'l');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCptspp', -1000, 'l');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCabcpp', 1000, 'u');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCptspp', 1000, 'u');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCt2pp', 0, 'b');

    % 计算优化前的琥珀酸产量
    fbaWT = optimizeCbModel(modelCurrent);
    succFluxWT = fbaWT.x(strcmp(modelCurrent.rxns, 'EX_succ_e'));
    growthRateWT = fbaWT.f;
    fprintf('优化前的琥珀酸产量: %.1f\n', succFluxWT);
    fprintf('优化前的生长速率: %.1f\n', growthRateWT);

    % 定义要搜索敲除的反应集合
    selectedRxnList = {'GLCabcpp'; 'GLCptspp'; 'HEX1'; 'PGI'; 'PFK'; 'FBA'; 'TPI'; 'GAPD'; ...
                       'PGK'; 'PGM'; 'ENO'; 'PYK'; 'LDH_D'; 'PFL'; 'ALCD2x'; 'PTAr'; 'ACKr'; ...
                       'G6PDH2r'; 'PGL'; 'GND'; 'RPI'; 'RPE'; 'TKT1'; 'TALA'; 'TKT2'; 'FUM'; ...
                       'FRD2'; 'SUCOAS'; 'AKGDH'; 'ACONTa'; 'ACONTb'; 'ICDHyr'; 'CS'; 'MDH'; ...
                       'MDH2'; 'MDH3'; 'ACALD'};

    % 设置optKnock选项
    options = struct('targetRxn', 'EX_succ_e', 'numDel', 2);
    constrOpt = struct('rxnList', {{biomass}}, 'values', 0.5*fbaWT.f, 'sense', 'G');

    % 运行optKnock
    optKnockSol = OptKnock(modelCurrent, selectedRxnList, options, constrOpt);

    % 存储结果
    resultsSecretion(i).configName = configNames{i};
    resultsSecretion(i).wildTypeSuccinate = succFluxWT;
    resultsSecretion(i).wildTypeGrowth = growthRateWT;

    if ~isempty(optKnockSol.rxnList)
        succFluxOpt = optKnockSol.fluxes(strcmp(modelCurrent.rxns, 'EX_succ_e'));
        growthRateOpt = optKnockSol.fluxes(strcmp(modelCurrent.rxns, biomass));
        resultsSecretion(i).optimizedSuccinate = succFluxOpt;
        resultsSecretion(i).optimizedGrowth = growthRateOpt;
        resultsSecretion(i).knockoutReactions = optKnockSol.rxnList;
        resultsSecretion(i).improvement = (succFluxOpt - succFluxWT) / succFluxWT * 100;

        fprintf('找到的敲除组合: ');
        for j = 1:length(optKnockSol.rxnList)
            if j == 1
                fprintf('%s', optKnockSol.rxnList{j});
            elseif j == length(optKnockSol.rxnList)
                fprintf(' 和 %s', optKnockSol.rxnList{j});
            else
                fprintf(', %s', optKnockSol.rxnList{j});
            end
        end
        fprintf('\n');
        fprintf('优化后的琥珀酸产量: %.2f\n', succFluxOpt);
        fprintf('优化后的生长速率: %.2f\n', growthRateOpt);
        fprintf('产量提升: %.1f%%\n', resultsSecretion(i).improvement);
    else
        resultsSecretion(i).optimizedSuccinate = succFluxWT;
        resultsSecretion(i).optimizedGrowth = growthRateWT;
        resultsSecretion(i).knockoutReactions = {};
        resultsSecretion(i).improvement = 0;
        fprintf('未找到有效的敲除组合\n');
    end
end

=== 方案二：是否启用不同分泌路径的比较 ===

--- 分泌配置: 仅乙酸盐 ---
优化前的琥珀酸产量: 0.0
优化前的生长速率: 0.0
未找到有效的敲除组合

--- 分泌配置: 仅二氧化碳 ---
优化前的琥珀酸产量: 0.0
优化前的生长速率: 0.0
未找到有效的敲除组合

--- 分泌配置: 仅乙醇 ---
优化前的琥珀酸产量: 0.0
优化前的生长速率: 0.0
未找到有效的敲除组合

--- 分泌配置: 仅甲酸盐 ---
优化前的琥珀酸产量: 0.0
优化前的生长速率: 0.0
未找到有效的敲除组合

--- 分泌配置: 仅乳酸盐 ---
优化前的琥珀酸产量: 0.0
优化前的生长速率: 0.0
未找到有效的敲除组合

--- 分泌配置: 仅琥珀酸盐 ---
优化前的琥珀酸产量: 8.1
优化前的生长速率: 0.1
找到的敲除组合: PFL 和 TKT2
优化后的琥珀酸产量: 8.21
优化后的生长速率: 0.14
产量提升: 0.8%

--- 分泌配置: 全部启用 ---
优化前的琥珀酸产量: 0.1
优化前的生长速率: 0.2
找到的敲除组合: PFL 和 RPI
优化后的琥珀酸产量: 2.75
优化后的生长速率: 0.14
产量提升: 3329.8%

--- 分泌配置: 全部禁用 ---
优化前的琥珀酸产量: 0.0
优化前的生长速率: 0.0
未找到有效的敲除组合
>> %% 方案三：不同反应列表下的敲除比较
fprintf('\n=== 方案三：不同反应列表下的敲除比较 ===\n');

% 定义4个固定的反应集合（基于iJO1366模型分析）
reactionSets = {
    % 中心碳代谢关键反应 - 涵盖糖酵解、TCA循环和回补反应
    % 参考iJO1366中的核心代谢路径：HEX1, PFK, FBA, GAPD, PYK, PDH, CS等
    {'HEX1'; 'PGI'; 'PFK'; 'FBA'; 'FBA3'; 'TPI'; 'GAPD'; 'PGK'; 'PGM'; 'ENO'; 'PYK';
     'PDH'; 'CS'; 'ACONTa'; 'ACONTb'; 'ICDHyr'; 'AKGDH'; 'SUCOAS'; 'SDH';
     'FUM'; 'MDH'; 'PPC'; 'PPCK'; 'ME1'; 'ME2'},

    % TCA循环和琥珀酸合成相关反应 - 专注于琥珀酸生产路径
    % 基于iJO1366中的TCA循环和琥珀酸相关：CS, ACONT, ICDHyr, AKGDH, SUCOAS等
    {'CS'; 'ACONTa'; 'ACONTb'; 'ICDHyr'; 'AKGDH'; 'SUCOAS'; 'SDH'; 'FUM'; 'MDH';
     'FRD2'; 'FRD3'; 'PPC'; 'PPCK'; 'ME1'; 'ME2'; 'PCK'; 'PPS'},

    % 糖酵解和发酵反应 - 主要涉及葡萄糖摄取和竞争性发酵路径
    % 参考iJO1366中的葡萄糖转运和发酵：GLCabcpp, GLCptspp, LDH_D, PFL等
    {'GLCabcpp'; 'GLCptspp'; 'HEX1'; 'PGI'; 'PFK'; 'PFK_2'; 'PFK_3'; 'FBA'; 'TPI'; 'GAPD';
     'PGK'; 'PGM'; 'ENO'; 'PYK'; 'LDH_D'; 'LDH_D2'; 'PFL'; 'ALCD2x'; 'PTAr'; 'ACKr'; 'ACALD'},

    % 磷酸戊糖途径和氧化还原平衡反应 - 影响NADPH和还原力平衡
    % 基于iJO1366中的PPP途径和脱氢酶：G6PDH2r, GND, TKT1, MDH2等
    {'G6PDH2r'; 'PGL'; 'GND'; 'RPI'; 'RPE'; 'TKT1'; 'TALA'; 'TKT2';
     'MDH2'; 'MDH3'; 'THD2'; 'NADTRHD'; 'NDH2'; 'GLUDy'; 'GLUDx'}
};

setNames = {
    '中心碳代谢关键反应（糖酵解+TCA+回补）',
    'TCA循环和琥珀酸合成路径',
    '糖酵解和发酵竞争路径',
    '磷酸戊糖途径和氧化还原平衡'
};

resultsReactionSets = struct();

for i = 1:length(reactionSets)
    fprintf('\n--- 反应集合: %s ---\n', setNames{i});

    % 创建模型副本
    modelCurrent = model;

    % 设置基本约束
    modelCurrent = changeRxnBounds(modelCurrent, 'EX_glc__D_e', -10, 'b');
    Exchange={'EX_o2_e';'EX_pi_e';'EX_so4_e'; 'EX_nh4_e'};
    Bounds=[0;-1000;-1000;-1000];
    modelCurrent = changeRxnBounds(modelCurrent, Exchange, Bounds, 'l');

    % 启用分泌路径
    Exchange={'EX_ac_e';'EX_co2_e';'EX_etoh_e';'EX_for_e';'EX_lac__D_e';'EX_succ_e'};
    Bounds=[1000;1000;1000;1000;1000;1000];
    modelCurrent = changeRxnBounds(modelCurrent, Exchange, Bounds, 'u');

    % 约束磷酸转移酶系统
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCabcpp', -1000, 'l');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCptspp', -1000, 'l');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCabcpp', 1000, 'u');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCptspp', 1000, 'u');
    modelCurrent = changeRxnBounds(modelCurrent, 'GLCt2pp', 0, 'b');

    % 计算优化前的琥珀酸产量
    fbaWT = optimizeCbModel(modelCurrent);
    succFluxWT = fbaWT.x(strcmp(modelCurrent.rxns, 'EX_succ_e'));
    growthRateWT = fbaWT.f;
    fprintf('优化前的琥珀酸产量: %.1f\n', succFluxWT);
    fprintf('优化前的生长速率: %.1f\n', growthRateWT);

    % 设置optKnock选项
    options = struct('targetRxn', 'EX_succ_e', 'numDel', 2);
    constrOpt = struct('rxnList', {{biomass}}, 'values', 0.5*fbaWT.f, 'sense', 'G');

    % 运行optKnock
    optKnockSol = OptKnock(modelCurrent, reactionSets{i}, options, constrOpt);

    % 存储结果
    resultsReactionSets(i).setName = setNames{i};
    resultsReactionSets(i).numReactions = length(reactionSets{i});
    resultsReactionSets(i).wildTypeSuccinate = succFluxWT;
    resultsReactionSets(i).wildTypeGrowth = growthRateWT;

    if ~isempty(optKnockSol.rxnList)
        succFluxOpt = optKnockSol.fluxes(strcmp(modelCurrent.rxns, 'EX_succ_e'));
        growthRateOpt = optKnockSol.fluxes(strcmp(modelCurrent.rxns, biomass));
        resultsReactionSets(i).optimizedSuccinate = succFluxOpt;
        resultsReactionSets(i).optimizedGrowth = growthRateOpt;
        resultsReactionSets(i).knockoutReactions = optKnockSol.rxnList;
        resultsReactionSets(i).improvement = (succFluxOpt - succFluxWT) / succFluxWT * 100;

        fprintf('找到的敲除组合: ');
        for j = 1:length(optKnockSol.rxnList)
            if j == 1
                fprintf('%s', optKnockSol.rxnList{j});
            elseif j == length(optKnockSol.rxnList)
                fprintf(' 和 %s', optKnockSol.rxnList{j});
            else
                fprintf(', %s', optKnockSol.rxnList{j});
            end
        end
        fprintf('\n');
        fprintf('优化后的琥珀酸产量: %.2f\n', succFluxOpt);
        fprintf('优化后的生长速率: %.2f\n', growthRateOpt);
        fprintf('产量提升: %.1f%%\n', resultsReactionSets(i).improvement);
    else
        resultsReactionSets(i).optimizedSuccinate = succFluxWT;
        resultsReactionSets(i).optimizedGrowth = growthRateWT;
        resultsReactionSets(i).knockoutReactions = {};
        resultsReactionSets(i).improvement = 0;
        fprintf('未找到有效的敲除组合\n');
    end
end

=== 方案三：不同反应列表下的敲除比较 ===

--- 反应集合: 中心碳代谢关键反应（糖酵解+TCA+回补） ---
优化前的琥珀酸产量: 0.1
优化前的生长速率: 0.2
找到的敲除组合: MDH 和 ME2
优化后的琥珀酸产量: 0.29
优化后的生长速率: 0.27
产量提升: 258.6%

--- 反应集合: TCA循环和琥珀酸合成路径 ---
优化前的琥珀酸产量: 0.1
优化前的生长速率: 0.2
找到的敲除组合: MDH 和 ME2
优化后的琥珀酸产量: 0.29
优化后的生长速率: 0.27
产量提升: 258.6%

--- 反应集合: 糖酵解和发酵竞争路径 ---
优化前的琥珀酸产量: 0.1
优化前的生长速率: 0.2
未找到有效的敲除组合

--- 反应集合: 磷酸戊糖途径和氧化还原平衡 ---
优化前的琥珀酸产量: 0.1
优化前的生长速率: 0.2
未找到有效的敲除组合
>> %% 方案四：原始tutorial_optKnock.m方案重现
fprintf('\n=== 方案四：原始tutorial_optKnock.m方案重现 ===\n');

% 本方案重现原始tutorial_optKnock.m中的四个示例，用于对比和验证

% 创建标准配置的模型
modelOriginal = model;
modelOriginal = changeRxnBounds(modelOriginal, 'EX_glc__D_e', -10, 'b');

% 设置原始文件中的约束条件
% 无约束的无机磷酸盐、硫酸盐和氨摄取路径
Exchange={'EX_o2_e';'EX_pi_e';'EX_so4_e'; 'EX_nh4_e'};
Bounds=[0;-1000;-1000;-1000];
modelOriginal = changeRxnBounds(modelOriginal, Exchange, Bounds, 'l');

% 启用乙酸盐、二氧化碳、乙醇、甲酸盐、乳酸盐和琥珀酸盐的分泌路径
Exchange={'EX_ac_e';'EX_co2_e';'EX_etoh_e';'EX_for_e';'EX_lac__D_e';'EX_succ_e'};
Bounds=[1000;1000;1000;1000;1000;1000];
modelOriginal = changeRxnBounds(modelOriginal, Exchange, Bounds, 'u');

% 约束磷酸转移酶系统
modelOriginal = changeRxnBounds(modelOriginal, 'GLCabcpp', -1000, 'l');
modelOriginal = changeRxnBounds(modelOriginal, 'GLCptspp', -1000, 'l');
modelOriginal = changeRxnBounds(modelOriginal, 'GLCabcpp', 1000, 'u');
modelOriginal = changeRxnBounds(modelOriginal, 'GLCptspp', 1000, 'u');
modelOriginal = changeRxnBounds(modelOriginal, 'GLCt2pp', 0, 'b');

% 计算野生型基准
fbaWT_original = optimizeCbModel(modelOriginal);
succFluxWT_original = fbaWT_original.x(strcmp(modelOriginal.rxns, 'EX_succ_e'));
growthRateWT_original = fbaWT_original.f;

fprintf('原始方案基准:\n');
fprintf('  琥珀酸产量: %.2f\n', succFluxWT_original);
fprintf('  乳酸盐产量: %.2f\n', fbaWT_original.x(strcmp(modelOriginal.rxns, 'EX_lac__D_e')));
fprintf('  生长速率: %.2f\n', growthRateWT_original);

% 使用原始文件中的反应列表
selectedRxnList_original = {'GLCabcpp'; 'GLCptspp'; 'HEX1'; 'PGI'; 'PFK'; 'FBA'; 'TPI'; 'GAPD'; ...
                           'PGK'; 'PGM'; 'ENO'; 'PYK'; 'LDH_D'; 'PFL'; 'ALCD2x'; 'PTAr'; 'ACKr'; ...
                           'G6PDH2r'; 'PGL'; 'GND'; 'RPI'; 'RPE'; 'TKT1'; 'TALA'; 'TKT2'; 'FUM'; ...
                           'FRD2'; 'SUCOAS'; 'AKGDH'; 'ACONTa'; 'ACONTb'; 'ICDHyr'; 'CS'; 'MDH'; ...
                           'MDH2'; 'MDH3'; 'ACALD'};

resultsOriginal = struct();

% 原始示例1：敲除2个反应提高琥珀酸产量
fprintf('\n--- 原始示例1：敲除2个反应提高琥珀酸产量 ---\n');
options = struct('targetRxn', 'EX_succ_e', 'numDel', 2);
constrOpt = struct('rxnList', {{biomass}}, 'values', 0.5*fbaWT_original.f, 'sense', 'G');

previousSolutions = cell(3, 1);
contPreviousSolutions = 1;

for iter = 1:3
    if iter == 1
        optKnockSol = OptKnock(modelOriginal, selectedRxnList_original, options, constrOpt);
    else
        optKnockSol = OptKnock(modelOriginal, selectedRxnList_original, options, constrOpt, previousSolutions);
    end

    if ~isempty(optKnockSol.rxnList)
        succFluxOpt = optKnockSol.fluxes(strcmp(modelOriginal.rxns, 'EX_succ_e'));
        growthRateOpt = optKnockSol.fluxes(strcmp(modelOriginal.rxns, biomass));

        resultsOriginal.ex1_solutions(iter).knockoutReactions = optKnockSol.rxnList;
        resultsOriginal.ex1_solutions(iter).succinateProduction = succFluxOpt;
        resultsOriginal.ex1_solutions(iter).growthRate = growthRateOpt;
        resultsOriginal.ex1_solutions(iter).improvement = (succFluxOpt - succFluxWT_original) / succFluxWT_original * 100;

        previousSolutions{contPreviousSolutions} = optKnockSol.rxnList;
        contPreviousSolutions = contPreviousSolutions + 1;

        fprintf('解%d: ', iter);
        for j = 1:length(optKnockSol.rxnList)
            if j == 1
                fprintf('%s', optKnockSol.rxnList{j});
            elseif j == length(optKnockSol.rxnList)
                fprintf(' 和 %s', optKnockSol.rxnList{j});
            else
                fprintf(', %s', optKnockSol.rxnList{j});
            end
        end
        fprintf('\n');
        fprintf('  琥珀酸产量: %.2f (提升 %.1f%%)\n', succFluxOpt, resultsOriginal.ex1_solutions(iter).improvement);
        fprintf('  生长速率: %.2f\n', growthRateOpt);

        % 执行耦合分析
        % 为analyzeOptKnock准备模型，确保包含目标函数
        modelForAnalysis = modelOriginal;
        if ~isfield(modelForAnalysis, 'optProblem') || ~isfield(modelForAnalysis.optProblem, 'F')
            % 设置生物质为目标函数
            modelForAnalysis = changeObjective(modelForAnalysis, biomass);
        end
        [type, maxGrowth, maxProd, minProd] = analyzeOptKnock(modelForAnalysis, optKnockSol.rxnList, 'EX_succ_e');
        fprintf('  耦合类型: %s\n', type);

        if strcmp(type, 'growth coupled')
            singleProductionEnvelope(modelOriginal, optKnockSol.rxnList, 'EX_succ_e', biomass, ...
                                   'savePlot', 1, 'showPlot', 1, ...
                                   'fileName', ['original_ex1_sol' num2str(iter)], ...
                                   'outputFolder', 'OptKnockResults');
        end
    else
        fprintf('未找到更多解\n');
        break;
    end
end

% 原始示例2：敲除3个反应提高琥珀酸产量
fprintf('\n--- 原始示例2：敲除3个反应提高琥珀酸产量 ---\n');
options = struct('targetRxn', 'EX_succ_e', 'numDel', 3);
constrOpt = struct('rxnList', {{biomass}}, 'values', 0.5*fbaWT_original.f, 'sense', 'G');

previousSolutions = cell(3, 1);
contPreviousSolutions = 1;

for iter = 1:2
    if iter == 1
        optKnockSol = OptKnock(modelOriginal, selectedRxnList_original, options, constrOpt);
    else
        optKnockSol = OptKnock(modelOriginal, selectedRxnList_original, options, constrOpt, previousSolutions);
    end

    if ~isempty(optKnockSol.rxnList)
        succFluxOpt = optKnockSol.fluxes(strcmp(modelOriginal.rxns, 'EX_succ_e'));
        growthRateOpt = optKnockSol.fluxes(strcmp(modelOriginal.rxns, biomass));

        resultsOriginal.ex2_solutions(iter).knockoutReactions = optKnockSol.rxnList;
        resultsOriginal.ex2_solutions(iter).succinateProduction = succFluxOpt;
        resultsOriginal.ex2_solutions(iter).growthRate = growthRateOpt;
        resultsOriginal.ex2_solutions(iter).improvement = (succFluxOpt - succFluxWT_original) / succFluxWT_original * 100;

        previousSolutions{contPreviousSolutions} = optKnockSol.rxnList;
        contPreviousSolutions = contPreviousSolutions + 1;

        fprintf('解%d: ', iter);
        for j = 1:length(optKnockSol.rxnList)
            if j == 1
                fprintf('%s', optKnockSol.rxnList{j});
            elseif j == length(optKnockSol.rxnList)
                fprintf(' 和 %s', optKnockSol.rxnList{j});
            else
                fprintf(', %s', optKnockSol.rxnList{j});
            end
        end
        fprintf('\n');
        fprintf('  琥珀酸产量: %.2f (提升 %.1f%%)\n', succFluxOpt, resultsOriginal.ex2_solutions(iter).improvement);
        fprintf('  生长速率: %.2f\n', growthRateOpt);

        % 执行耦合分析
        % 为analyzeOptKnock准备模型，确保包含目标函数
        modelForAnalysis = modelOriginal;
        if ~isfield(modelForAnalysis, 'optProblem') || ~isfield(modelForAnalysis.optProblem, 'F')
            % 设置生物质为目标函数
            modelForAnalysis = changeObjective(modelForAnalysis, biomass);
        end
        [type, maxGrowth, maxProd, minProd] = analyzeOptKnock(modelForAnalysis, optKnockSol.rxnList, 'EX_succ_e');
        fprintf('  耦合类型: %s\n', type);
    else
        fprintf('未找到更多解\n');
        break;
    end
end

% 原始示例3：敲除3个反应提高乳酸盐产量
fprintf('\n--- 原始示例3：敲除3个反应提高乳酸盐产量 ---\n');
options = struct('targetRxn', 'EX_lac__D_e', 'numDel', 3);
constrOpt = struct('rxnList', {{biomass}}, 'values', 0.5*fbaWT_original.f, 'sense', 'G');

previousSolutions = cell(2, 1);
contPreviousSolutions = 1;

for iter = 1:2
    if iter == 1
        optKnockSol = OptKnock(modelOriginal, selectedRxnList_original, options, constrOpt);
    else
        optKnockSol = OptKnock(modelOriginal, selectedRxnList_original, options, constrOpt, previousSolutions);
    end

    if ~isempty(optKnockSol.rxnList)
        lactFluxOpt = optKnockSol.fluxes(strcmp(modelOriginal.rxns, 'EX_lac__D_e'));
        growthRateOpt = optKnockSol.fluxes(strcmp(modelOriginal.rxns, biomass));

        resultsOriginal.ex3_solutions(iter).knockoutReactions = optKnockSol.rxnList;
        resultsOriginal.ex3_solutions(iter).lactateProduction = lactFluxOpt;
        resultsOriginal.ex3_solutions(iter).growthRate = growthRateOpt;

        % 计算乳酸盐产量提升（与野生型比较）
        lactFluxWT = fbaWT_original.x(strcmp(modelOriginal.rxns, 'EX_lac__D_e'));
        if abs(lactFluxWT) < 1e-6 % 如果野生型产量接近0
            if lactFluxOpt > 1e-6
                improvement = Inf; % 从无到有，标记为无限提升
                improvement_str = '从无到有';
            else
                improvement = 0; % 都没有产量
                improvement_str = '无变化';
            end
        else
            improvement = (lactFluxOpt - lactFluxWT) / lactFluxWT * 100;
            improvement_str = sprintf('%.1f%%', improvement);
        end
        resultsOriginal.ex3_solutions(iter).improvement = improvement;

        previousSolutions{contPreviousSolutions} = optKnockSol.rxnList;
        contPreviousSolutions = contPreviousSolutions + 1;

        fprintf('解%d: ', iter);
        for j = 1:length(optKnockSol.rxnList)
            if j == 1
                fprintf('%s', optKnockSol.rxnList{j});
            elseif j == length(optKnockSol.rxnList)
                fprintf(' 和 %s', optKnockSol.rxnList{j});
            else
                fprintf(', %s', optKnockSol.rxnList{j});
            end
        end
        fprintf('\n');
        fprintf('  乳酸盐产量: %.2f (提升 %s)\n', lactFluxOpt, improvement_str);
        fprintf('  生长速率: %.2f\n', growthRateOpt);

        % 执行耦合分析
        % 为analyzeOptKnock准备模型，确保包含目标函数
        modelForAnalysis = modelOriginal;
        if ~isfield(modelForAnalysis, 'optProblem') || ~isfield(modelForAnalysis.optProblem, 'F')
            % 设置生物质为目标函数
            modelForAnalysis = changeObjective(modelForAnalysis, biomass);
        end
        [type, maxGrowth, maxProd, minProd] = analyzeOptKnock(modelForAnalysis, optKnockSol.rxnList, 'EX_lac__D_e');
        fprintf('  耦合类型: %s\n', type);
    else
        fprintf('未找到更多解\n');
        break;
    end
end

=== 方案四：原始tutorial_optKnock.m方案重现 ===
原始方案基准:
  琥珀酸产量: 0.08
  乳酸盐产量: 0.00
  生长速率: 0.24

--- 原始示例1：敲除2个反应提高琥珀酸产量 ---
解1: PFL 和 RPI
  琥珀酸产量: 2.75 (提升 3329.8%)
  生长速率: 0.14
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
  耦合类型: growth coupled non unique
解2: PFL 和 TKT2
  琥珀酸产量: 1.68 (提升 1997.8%)
  生长速率: 0.22
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
  耦合类型: growth coupled non unique
解3: PFL 和 RPE
  琥珀酸产量: 1.44 (提升 1702.1%)
  生长速率: 0.22
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
  耦合类型: growth coupled non unique

--- 原始示例2：敲除3个反应提高琥珀酸产量 ---
解1: ALCD2x, LDH_D 和 PFL
  琥珀酸产量: 8.81 (提升 10904.5%)
  生长速率: 0.15
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
  耦合类型: growth coupled
解2: ACALD, LDH_D 和 PFL
  琥珀酸产量: 8.81 (提升 10904.5%)
  生长速率: 0.15
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
  耦合类型: growth coupled non unique

--- 原始示例3：敲除3个反应提高乳酸盐产量 ---
解1: PGI, PTAr 和 TKT1
  乳酸盐产量: 18.21 (提升 从无到有)
  生长速率: 0.12
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
  耦合类型: non unique
解2: ACKr, GND 和 PGI
  乳酸盐产量: 18.21 (提升 从无到有)
  生长速率: 0.12
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
  耦合类型: non unique
>> %% 方案五：综合最佳方案的详细分析
fprintf('\n=== 方案五：综合最佳方案的详细分析 ===\n');

% 创建最佳配置的模型
modelBest = model;
modelBest = changeRxnBounds(modelBest, 'EX_glc__D_e', -10, 'b');
Exchange={'EX_o2_e';'EX_pi_e';'EX_so4_e'; 'EX_nh4_e'};
Bounds=[0;-1000;-1000;-1000];
modelBest = changeRxnBounds(modelBest, Exchange, Bounds, 'l');
Exchange={'EX_ac_e';'EX_co2_e';'EX_etoh_e';'EX_for_e';'EX_lac__D_e';'EX_succ_e'};
Bounds=[1000;1000;1000;1000;1000;1000];
modelBest = changeRxnBounds(modelBest, Exchange, Bounds, 'u');
modelBest = changeRxnBounds(modelBest, 'GLCabcpp', -1000, 'l');
modelBest = changeRxnBounds(modelBest, 'GLCptspp', -1000, 'l');
modelBest = changeRxnBounds(modelBest, 'GLCabcpp', 1000, 'u');
modelBest = changeRxnBounds(modelBest, 'GLCptspp', 1000, 'u');
modelBest = changeRxnBounds(modelBest, 'GLCt2pp', 0, 'b');

% 计算野生型基准
fbaWT = optimizeCbModel(modelBest);
succFluxWT = fbaWT.x(strcmp(modelBest.rxns, 'EX_succ_e'));
growthRateWT = fbaWT.f;

fprintf('野生型基准:\n');
fprintf('  琥珀酸产量: %.2f\n', succFluxWT);
fprintf('  生长速率: %.2f\n', growthRateWT);

% 尝试不同的敲除策略
knockoutStrategies = {
    struct('name', '双敲除策略', 'numDel', 2),
    struct('name', '三敲除策略', 'numDel', 3),
    struct('name', '四敲除策略', 'numDel', 4)
};

selectedRxnListComprehensive = {'GLCabcpp'; 'GLCptspp'; 'HEX1'; 'PGI'; 'PFK'; 'FBA'; 'TPI'; 'GAPD'; ...
                               'PGK'; 'PGM'; 'ENO'; 'PYK'; 'LDH_D'; 'PFL'; 'ALCD2x'; 'PTAr'; 'ACKr'; ...
                               'G6PDH2r'; 'PGL'; 'GND'; 'RPI'; 'RPE'; 'TKT1'; 'TALA'; 'TKT2'; 'FUM'; ...
                               'FRD2'; 'SUCOAS'; 'AKGDH'; 'ACONTa'; 'ACONTb'; 'ICDHyr'; 'CS'; 'MDH'; ...
                               'MDH2'; 'MDH3'; 'ACALD'};

resultsComprehensive = struct();

for i = 1:length(knockoutStrategies)
    strategy = knockoutStrategies{i};
    fprintf('\n--- %s (最多敲除%d个反应) ---\n', strategy.name, strategy.numDel);

    % 设置optKnock选项
    options = struct('targetRxn', 'EX_succ_e', 'numDel', strategy.numDel);
    constrOpt = struct('rxnList', {{biomass}}, 'values', 0.5*fbaWT.f, 'sense', 'G');

    % 尝试找到多个解
    previousSolutions = cell(5, 1);
    contPreviousSolutions = 1;

    for j = 1:3 % 每种策略尝试3个不同的解
        if j == 1
            optKnockSol = OptKnock(modelBest, selectedRxnListComprehensive, options, constrOpt);
        else
            optKnockSol = OptKnock(modelBest, selectedRxnListComprehensive, options, constrOpt, previousSolutions);
        end

        if ~isempty(optKnockSol.rxnList)
            succFluxOpt = optKnockSol.fluxes(strcmp(modelBest.rxns, 'EX_succ_e'));
            growthRateOpt = optKnockSol.fluxes(strcmp(modelBest.rxns, biomass));

            % 执行耦合分析
            % 为analyzeOptKnock准备模型，确保包含目标函数
            modelForAnalysis = modelBest;
            if ~isfield(modelForAnalysis, 'optProblem') || ~isfield(modelForAnalysis.optProblem, 'F')
                % 设置生物质为目标函数
                modelForAnalysis = changeObjective(modelForAnalysis, biomass);
            end
            [type, maxGrowth, maxProd, minProd] = analyzeOptKnock(modelForAnalysis, optKnockSol.rxnList, 'EX_succ_e');

            % 存储结果
            resultsComprehensive(i).solutions(j).knockoutReactions = optKnockSol.rxnList;
            resultsComprehensive(i).solutions(j).succinateProduction = succFluxOpt;
            resultsComprehensive(i).solutions(j).growthRate = growthRateOpt;
            resultsComprehensive(i).solutions(j).improvement = (succFluxOpt - succFluxWT) / succFluxWT * 100;
            resultsComprehensive(i).solutions(j).couplingType = type;
            resultsComprehensive(i).solutions(j).maxGrowth = maxGrowth;
            resultsComprehensive(i).solutions(j).maxProduction = maxProd;
            resultsComprehensive(i).solutions(j).minProduction = minProd;

            previousSolutions{contPreviousSolutions} = optKnockSol.rxnList;
            contPreviousSolutions = contPreviousSolutions + 1;

            fprintf('解%d: ', j);
            for k = 1:length(optKnockSol.rxnList)
                if k == 1
                    fprintf('%s', optKnockSol.rxnList{k});
                elseif k == length(optKnockSol.rxnList)
                    fprintf(' 和 %s', optKnockSol.rxnList{k});
                else
                    fprintf(', %s', optKnockSol.rxnList{k});
                end
            end
            fprintf('\n');
            fprintf('  琥珀酸产量: %.2f (提升 %.1f%%)\n', succFluxOpt, resultsComprehensive(i).solutions(j).improvement);
            fprintf('  生长速率: %.2f\n', growthRateOpt);
            fprintf('  耦合类型: %s\n', type);
            fprintf('  最大生长速率: %.2f\n', maxGrowth);
            fprintf('  产量范围: %.2f - %.2f\n', minProd, maxProd);

            % 如果是生长耦合的，生成生产包络图
            if strcmp(type, 'growth coupled')
                singleProductionEnvelope(modelBest, optKnockSol.rxnList, 'EX_succ_e', biomass, ...
                                       'savePlot', 1, 'showPlot', 1, ...
                                       'fileName', ['comprehensive_' strategy.name '_sol' num2str(j)], ...
                                       'outputFolder', 'OptKnockResults');
            end
        else
            fprintf('未找到更多解\n');
            break;
        end
    end
    resultsComprehensive(i).strategyName = strategy.name;
    resultsComprehensive(i).numDel = strategy.numDel;
end

=== 方案五：综合最佳方案的详细分析 ===
野生型基准:
  琥珀酸产量: 0.08
  生长速率: 0.24

--- 双敲除策略 (最多敲除2个反应) ---
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解1: PFL 和 RPI
  琥珀酸产量: 2.75 (提升 3329.8%)
  生长速率: 0.14
  耦合类型: growth coupled non unique
  最大生长速率: 0.12
  产量范围: 0.04 - 2.31
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解2: PFL 和 TKT2
  琥珀酸产量: 1.68 (提升 1997.8%)
  生长速率: 0.22
  耦合类型: growth coupled non unique
  最大生长速率: 0.18
  产量范围: 0.06 - 1.41
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解3: PFL 和 RPE
  琥珀酸产量: 1.44 (提升 1702.1%)
  生长速率: 0.22
  耦合类型: growth coupled non unique
  最大生长速率: 0.18
  产量范围: 0.06 - 1.22

--- 三敲除策略 (最多敲除3个反应) ---
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解1: ALCD2x, LDH_D 和 PFL
  琥珀酸产量: 8.81 (提升 10904.5%)
  生长速率: 0.15
  耦合类型: growth coupled
  最大生长速率: 0.11
  产量范围: 9.11 - 9.11
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解2: ACALD, LDH_D 和 PFL
  琥珀酸产量: 8.81 (提升 10904.5%)
  生长速率: 0.15
  耦合类型: growth coupled non unique
  最大生长速率: 0.11
  产量范围: 4.23 - 9.11
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解3: LDH_D, PFL 和 RPI
  琥珀酸产量: 2.75 (提升 3329.8%)
  生长速率: 0.14
  耦合类型: growth coupled non unique
  最大生长速率: 0.12
  产量范围: 0.04 - 2.31

--- 四敲除策略 (最多敲除4个反应) ---
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解1: ACALD, G6PDH2r, LDH_D 和 PFL
  琥珀酸产量: 8.81 (提升 10904.5%)
  生长速率: 0.15
  耦合类型: growth coupled non unique
  最大生长速率: 0.11
  产量范围: 4.23 - 9.11
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解2: ALCD2x, G6PDH2r, LDH_D 和 PFL
  琥珀酸产量: 8.81 (提升 10904.5%)
  生长速率: 0.15
  耦合类型: growth coupled
  最大生长速率: 0.11
  产量范围: 9.11 - 9.11
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 49 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 56 行) 
  不包含字段的 struct。

警告: optProblem.F missing 
> 位置：optimizeCbModel (第 897 行)
位置: analyzeOptKnock (第 57 行) 
解3: ACALD, LDH_D 和 PFL
  琥珀酸产量: 8.81 (提升 10904.5%)
  生长速率: 0.15
  耦合类型: growth coupled non unique
  最大生长速率: 0.11
  产量范围: 4.23 - 9.11
>> %% 总结与比较
fprintf('\n=== 总结与比较 ===\n');

% 1. 葡萄糖摄取量影响
fprintf('\n1. 葡萄糖摄取量对优化结果的影响:\n');
fprintf('   摄取量 | 野生型产量 | 优化后产量 | 提升幅度\n');
fprintf('   ------|-----------|-----------|--------\n');
for i = 1:length(resultsGlucose)
    fprintf('   %4d | %9.2f | %11.2f | %7.1f%%\n', ...
            resultsGlucose(i).glucoseUptake, ...
            resultsGlucose(i).wildTypeSuccinate, ...
            resultsGlucose(i).optimizedSuccinate, ...
            resultsGlucose(i).improvement);
end

% 2. 分泌路径影响
fprintf('\n2. 分泌路径配置对优化结果的影响:\n');
fprintf('   配置名称 | 野生型产量 | 优化后产量 | 提升幅度\n');
fprintf('   --------|-----------|-----------|--------\n');
for i = 1:length(resultsSecretion)
    fprintf('   %-8s | %9.2f | %11.2f | %7.1f%%\n', ...
            resultsSecretion(i).configName, ...
            resultsSecretion(i).wildTypeSuccinate, ...
            resultsSecretion(i).optimizedSuccinate, ...
            resultsSecretion(i).improvement);
end

% 3. 反应集合影响
fprintf('\n3. 反应集合对优化结果的影响:\n');
fprintf('   集合名称 | 反应数量 | 野生型产量 | 优化后产量 | 提升幅度\n');
fprintf('   --------|---------|-----------|-----------|--------\n');
for i = 1:length(resultsReactionSets)
    fprintf('   %-8s | %7d | %9.2f | %11.2f | %7.1f%%\n', ...
            resultsReactionSets(i).setName, ...
            resultsReactionSets(i).numReactions, ...
            resultsReactionSets(i).wildTypeSuccinate, ...
            resultsReactionSets(i).optimizedSuccinate, ...
            resultsReactionSets(i).improvement);
end

% 4. 原始tutorial_optKnock.m方案结果
fprintf('\n4. 原始tutorial_optKnock.m方案结果:\n');

% 显示原始示例1的结果
fprintf('\n   原始示例1 (敲除2个反应提高琥珀酸):\n');
if isfield(resultsOriginal, 'ex1_solutions') && ~isempty(resultsOriginal.ex1_solutions)
    for i = 1:length(resultsOriginal.ex1_solutions)
        if isfield(resultsOriginal.ex1_solutions(i), 'knockoutReactions') && ~isempty(resultsOriginal.ex1_solutions(i).knockoutReactions)
            fprintf('     解%d: 敲除', i);
            for j = 1:length(resultsOriginal.ex1_solutions(i).knockoutReactions)
                if j == 1
                    fprintf('%s', resultsOriginal.ex1_solutions(i).knockoutReactions{j});
                elseif j == length(resultsOriginal.ex1_solutions(i).knockoutReactions)
                    fprintf(' 和 %s', resultsOriginal.ex1_solutions(i).knockoutReactions{j});
                else
                    fprintf(', %s', resultsOriginal.ex1_solutions(i).knockoutReactions{j});
                end
            end
            fprintf(', 产量: %.2f (提升 %.1f%%)\n', ...
                    resultsOriginal.ex1_solutions(i).succinateProduction, ...
                    resultsOriginal.ex1_solutions(i).improvement);
        end
    end
else
    fprintf('     未找到有效解\n');
end

% 显示原始示例2的结果
fprintf('\n   原始示例2 (敲除3个反应提高琥珀酸):\n');
if isfield(resultsOriginal, 'ex2_solutions') && ~isempty(resultsOriginal.ex2_solutions)
    for i = 1:length(resultsOriginal.ex2_solutions)
        if isfield(resultsOriginal.ex2_solutions(i), 'knockoutReactions') && ~isempty(resultsOriginal.ex2_solutions(i).knockoutReactions)
            fprintf('     解%d: 敲除', i);
            for j = 1:length(resultsOriginal.ex2_solutions(i).knockoutReactions)
                if j == 1
                    fprintf('%s', resultsOriginal.ex2_solutions(i).knockoutReactions{j});
                elseif j == length(resultsOriginal.ex2_solutions(i).knockoutReactions)
                    fprintf(' 和 %s', resultsOriginal.ex2_solutions(i).knockoutReactions{j});
                else
                    fprintf(', %s', resultsOriginal.ex2_solutions(i).knockoutReactions{j});
                end
            end
            fprintf(', 产量: %.2f (提升 %.1f%%)\n', ...
                    resultsOriginal.ex2_solutions(i).succinateProduction, ...
                    resultsOriginal.ex2_solutions(i).improvement);
        end
    end
else
    fprintf('     未找到有效解\n');
end

% 显示原始示例3的结果
fprintf('\n   原始示例3 (敲除3个反应提高乳酸盐):\n');
if isfield(resultsOriginal, 'ex3_solutions') && ~isempty(resultsOriginal.ex3_solutions)
    for i = 1:length(resultsOriginal.ex3_solutions)
        if isfield(resultsOriginal.ex3_solutions(i), 'knockoutReactions') && ~isempty(resultsOriginal.ex3_solutions(i).knockoutReactions)
            fprintf('     解%d: 敲除', i);
            for j = 1:length(resultsOriginal.ex3_solutions(i).knockoutReactions)
                if j == 1
                    fprintf('%s', resultsOriginal.ex3_solutions(i).knockoutReactions{j});
                elseif j == length(resultsOriginal.ex3_solutions(i).knockoutReactions)
                    fprintf(' 和 %s', resultsOriginal.ex3_solutions(i).knockoutReactions{j});
                else
                    fprintf(', %s', resultsOriginal.ex3_solutions(i).knockoutReactions{j});
                end
            end
            % 为乳酸盐结果准备提升字符串
            improvement_val = resultsOriginal.ex3_solutions(i).improvement;
            if isinf(improvement_val)
                improvement_str_summary = '从无到有';
            elseif improvement_val == 0
                improvement_str_summary = '无变化';
            else
                improvement_str_summary = sprintf('%.1f%%', improvement_val);
            end
            fprintf(', 产量: %.2f (提升 %s)\n', ...
                    resultsOriginal.ex3_solutions(i).lactateProduction, ...
                    improvement_str_summary);
        end
    end
else
    fprintf('     未找到有效解\n');
end

% 5. 综合最佳方案推荐
fprintf('\n5. 综合最佳方案推荐:\n');
bestImprovement = 0;
bestStrategy = '';
bestSolution = struct();
bestSource = '';

% 检查所有方案中的最佳结果

% 检查方案一（不同葡萄糖摄取量）
for i = 1:length(resultsGlucose)
    if resultsGlucose(i).improvement > bestImprovement
        bestImprovement = resultsGlucose(i).improvement;
        bestStrategy = sprintf('葡萄糖摄取量 %d mmol/grDW*hr', resultsGlucose(i).glucoseUptake);
        bestSolution.knockoutReactions = resultsGlucose(i).knockoutReactions;
        bestSolution.succinateProduction = resultsGlucose(i).optimizedSuccinate;
        bestSolution.growthRate = resultsGlucose(i).optimizedGrowth;
        bestSource = '方案一';
    end
end

% 检查方案二（不同分泌路径）
for i = 1:length(resultsSecretion)
    if resultsSecretion(i).improvement > bestImprovement
        bestImprovement = resultsSecretion(i).improvement;
        bestStrategy = sprintf('分泌配置: %s', resultsSecretion(i).configName);
        bestSolution.knockoutReactions = resultsSecretion(i).knockoutReactions;
        bestSolution.succinateProduction = resultsSecretion(i).optimizedSuccinate;
        bestSolution.growthRate = resultsSecretion(i).optimizedGrowth;
        bestSource = '方案二';
    end
end

% 检查方案三（不同反应集合）
for i = 1:length(resultsReactionSets)
    if resultsReactionSets(i).improvement > bestImprovement
        bestImprovement = resultsReactionSets(i).improvement;
        bestStrategy = sprintf('反应集合: %s', resultsReactionSets(i).setName);
        bestSolution.knockoutReactions = resultsReactionSets(i).knockoutReactions;
        bestSolution.succinateProduction = resultsReactionSets(i).optimizedSuccinate;
        bestSolution.growthRate = resultsReactionSets(i).optimizedGrowth;
        bestSource = '方案三';
    end
end

% 检查方案四（原始tutorial_optKnock.m方案）
if isfield(resultsOriginal, 'ex1_solutions')
    for i = 1:length(resultsOriginal.ex1_solutions)
        if isfield(resultsOriginal.ex1_solutions(i), 'improvement') && ...
           resultsOriginal.ex1_solutions(i).improvement > bestImprovement
            bestImprovement = resultsOriginal.ex1_solutions(i).improvement;
            bestStrategy = '原始示例1: 敲除2个反应';
            bestSolution.knockoutReactions = resultsOriginal.ex1_solutions(i).knockoutReactions;
            bestSolution.succinateProduction = resultsOriginal.ex1_solutions(i).succinateProduction;
            bestSolution.growthRate = resultsOriginal.ex1_solutions(i).growthRate;
            bestSource = '方案四';
        end
    end
end

if isfield(resultsOriginal, 'ex2_solutions')
    for i = 1:length(resultsOriginal.ex2_solutions)
        if isfield(resultsOriginal.ex2_solutions(i), 'improvement') && ...
           resultsOriginal.ex2_solutions(i).improvement > bestImprovement
            bestImprovement = resultsOriginal.ex2_solutions(i).improvement;
            bestStrategy = '原始示例2: 敲除3个反应';
            bestSolution.knockoutReactions = resultsOriginal.ex2_solutions(i).knockoutReactions;
            bestSolution.succinateProduction = resultsOriginal.ex2_solutions(i).succinateProduction;
            bestSolution.growthRate = resultsOriginal.ex2_solutions(i).growthRate;
            bestSource = '方案四';
        end
    end
end

% 检查方案五（综合分析）
for i = 1:length(resultsComprehensive)
    for j = 1:length(resultsComprehensive(i).solutions)
        if resultsComprehensive(i).solutions(j).improvement > bestImprovement
            bestImprovement = resultsComprehensive(i).solutions(j).improvement;
            bestStrategy = resultsComprehensive(i).strategyName;
            bestSolution = resultsComprehensive(i).solutions(j);
            bestSource = '方案五';
        end
    end
end

if ~isempty(fieldnames(bestSolution))
    fprintf('   推荐方案: %s\n', bestStrategy);
    fprintf('   敲除反应: ');
    for i = 1:length(bestSolution.knockoutReactions)
        if i == 1
            fprintf('%s', bestSolution.knockoutReactions{i});
        elseif i == length(bestSolution.knockoutReactions)
            fprintf(' 和 %s', bestSolution.knockoutReactions{i});
        else
            fprintf(', %s', bestSolution.knockoutReactions{i});
        end
    end
    fprintf('\n');
    fprintf('   预期琥珀酸产量: %.2f (相比野生型提升 %.1f%%)\n', ...
            bestSolution.succinateProduction, bestImprovement);
    fprintf('   预期生长速率: %.2f\n', bestSolution.growthRate);
    if isfield(bestSolution, 'couplingType')
        fprintf('   耦合类型: %s\n', bestSolution.couplingType);
    end
    fprintf('   方案来源: %s\n', bestSource);
else
    fprintf('   未找到明显的优化方案\n');
end

=== 总结与比较 ===

1. 葡萄糖摄取量对优化结果的影响:
   摄取量 | 野生型产量 | 优化后产量 | 提升幅度
   ------|-----------|-----------|--------
      5 |      0.03 |        1.37 |  3907.5%
     10 |      0.08 |        2.75 |  3329.8%
     15 |      0.13 |        4.12 |  3172.5%
     20 |      0.17 |        5.49 |  3099.2%

2. 分泌路径配置对优化结果的影响:
   配置名称 | 野生型产量 | 优化后产量 | 提升幅度
   --------|-----------|-----------|--------
   仅乙酸盐     |      0.00 |        0.00 |     0.0%
   仅二氧化碳    |      0.00 |        0.00 |     0.0%
   仅乙醇      |      0.00 |        0.00 |     0.0%
   仅甲酸盐     |      0.00 |        0.00 |     0.0%
   仅乳酸盐     |      0.00 |        0.00 |     0.0%
   仅琥珀酸盐    |      8.15 |        8.21 |     0.8%
   全部启用     |      0.08 |        2.75 |  3329.8%
   全部禁用     |      0.00 |        0.00 |     0.0%

3. 反应集合对优化结果的影响:
   集合名称 | 反应数量 | 野生型产量 | 优化后产量 | 提升幅度
   --------|---------|-----------|-----------|--------
   中心碳代谢关键反应（糖酵解+TCA+回补） |      25 |      0.08 |        0.29 |   258.6%
   TCA循环和琥珀酸合成路径 |      17 |      0.08 |        0.29 |   258.6%
   糖酵解和发酵竞争路径 |      21 |      0.08 |        0.08 |     0.0%
   磷酸戊糖途径和氧化还原平衡 |      15 |      0.08 |        0.08 |     0.0%

4. 原始tutorial_optKnock.m方案结果:

   原始示例1 (敲除2个反应提高琥珀酸):
     解1: 敲除PFL 和 RPI, 产量: 2.75 (提升 3329.8%)
     解2: 敲除PFL 和 TKT2, 产量: 1.68 (提升 1997.8%)
     解3: 敲除PFL 和 RPE, 产量: 1.44 (提升 1702.1%)

   原始示例2 (敲除3个反应提高琥珀酸):
     解1: 敲除ALCD2x, LDH_D 和 PFL, 产量: 8.81 (提升 10904.5%)
     解2: 敲除ACALD, LDH_D 和 PFL, 产量: 8.81 (提升 10904.5%)

   原始示例3 (敲除3个反应提高乳酸盐):
     解1: 敲除PGI, PTAr 和 TKT1, 产量: 18.21 (提升 从无到有)
     解2: 敲除ACKr, GND 和 PGI, 产量: 18.21 (提升 从无到有)

5. 综合最佳方案推荐:
   推荐方案: 原始示例2: 敲除3个反应
   敲除反应: ALCD2x, LDH_D 和 PFL
   预期琥珀酸产量: 8.81 (相比野生型提升 10904.5%)
   预期生长速率: 0.15
   方案来源: 方案四
>> 